<!DOCTYPE html>
<html>
<head>
    <title>C++ with Node.js</title>
    <meta charset='utf-8'>
    <script src='js/slides.js'></script>
</head>
<body style='display: none'>
    <section class='slides layout-regular template-default'>
        <article>
            <h1>
                C++ modules in node.js
            </h1>
            <p>
                Roman Shtylman
            </p>
        </article>

        <article class="build">
            <h3>intro</h3>
            <div>
                <h4>me</h4>
                <ul>
                    <li>Using node ~year</li>
                </ul>
            </div>
            <div>
                <h4>node.js</h4>
                <ul>
                    <li>Javascript is everywhere (and growing)</li>
                    <li>Async event-based<br/>
                        <small>twisted | event machine</small>
                    </li>
                    <li>Created in 2008, runs on v8<br/>
                        <small>new hotness</small>
                    </li>
                </ul>
                <img class="centered" src="images/nodejs_logo.png"/>
            </div>
        </article>

        <article class="build">
            <h3>why do c++ at all?</h3>
            <table>
                <tr>
                    <th width="50%"><center>pro</center></th>
                    <th><center>con</center></th>
                </tr>
                <tr>
                    <td>
                        <ul class="build">
                            <li>"legacy" code</li>
                            <li>performance*</li>
                            <li>extend app capabilities</li>
                            <li>bulk processing</li>
                            <li>exotic algorithms</li>
                        </ul>
                    </td>
                    <td>
                        <ul class="build">
                            <li>deployment</li>
                            <li>performance*</li>
                            <li>developer capability</li>
                            <li>unstable and ever changing</li>
                        </ul>
                    </td>
                </tr>
            </table>
            <small>* if you can't prove it helped, it didn't help</small>
            <p>
                Crossing the js/c++ barrier has overhead.
            </p>
            <p>
                Thread pool has overhead.
            </p>
        </article>

        <article class="build">
            <h3>understanding v8 and node.js</h3>
            <p>
                Unless you understand javascript and node.js, you will fail.
            </p>
            <table>
                <tr>
                    <td style="border: 0px">
                        <ul class="build">
                            <li>callback heavy<br/><small>closures</small></li>
                            <li>libuv/libev/libeio<br/><small>thread pool</small></li>
                            <li>block if you want<br/><small>multiple processes</small></li>
                            <li>build from source<br/><small>stay up to date</small></li>
                        </ul>
                    </td>
                    <td style="border: 0px">
                <pre class="prettyprint lang-js">
// this is not uncommon
foo('param1', function(err, res) {
    if (err)
        // note error

    bar(res.param2, function(err, res2) {
        if (err)
            // note error
    });
});</pre>
                    </td>
                </tr>
            </table>
        </article>

        <article class="build">
            <h3>about the code examples</h3>
            <p>
                The examples in the project tree (should) be well doumented and are meant to be read.
            </p>
            <p>
                In some cases, more verbose code is used to illustrate what happens.
            </p>
            <p>
                There is more than one way to do things; the examples try to make that clear where possible.
            </p>
            <p>
                <a href="https://github.com/shtylman/node-presentation">https://github.com/shtylman/node-presentation</a>
            </p>
        </article>

        <article>
            <h3>hello world</h3>
            <p>
                Understanding how modules are loaded is very important!<br/>
                <a target="_new" href="http://nodejs.org/docs/latest/api/modules.html">http://nodejs.org/docs/latest/api/modules.html</a>
            </p>
            <h4>
                Convert the following into c++ code
            </h4>
            <pre class="prettyprint lang-js">
// file: hello_native.js
exports.hello = function() {
    return 'world';
};</pre>
            <small>see <em>hello_world</em> directory in project tree</small>
        </article>

        <article class="smaller">
            <h3>hello world - async</h3>
            <p>
                doesn't matter. Sometimes the order
            </p>
            <pre class="prettyprint lang-js">
// file: hello_native.js

// will print a string to the screen asyncronously
// i.e. the string will not print until the next cycle
// of the eventloop
exports.print = function(string, cb) {
    process.nextTick(function() {
        process.stdout.write(string);
        cb();
    });
};

// print string syncronously (immediately)
// Note: node.js convention is to suffix 'Sync' after the name
// You could just detect the cb parameter.
exports.printSync = function(string) {
    process.stdout.write(string);
};</pre>
<pre class="prettyprint lang-js">
print('Sometimes the ', function() {
    printSync('order\n');
});
printSync('doesn\'t matter. ');
</pre>
        </article>

        <article>
            <h3>hello world - async con't</h3>
            <p>
                The two implementations are not completely identical. The native one could still block if a complex algorithm was run*. The c++ one always runs in a separate thread.
            </p>
            <p>
                You would never async something so trivial, this is just an example.
            </p>
            <div class="build">
            <div>
            <h4>alternate</h4>
            <p>
                See <em>hello_bindings.js</em> in <em>hello_world_async</em> for an alternate way to expose the bindings.
            </p>
            <p>
                I favor this approach as it separates the c++ bindings from the user facing js. I find it more flexible to api changes and argument mangling.
            </p>
            </div>
            </div>
            <small style="position:absolute;bottom: 10px">* multiple processes or forking is the node.js way to solve it natively</small>
        </article>

        <article>
            <h3>execution interlude</h3>
            <p>
                What is the result of the following?
            </p>
            <pre class="prettyprint lang-js">
try {
    process.nextTick(function() {
        throw new Error('error!');
    });
} catch (e) {
    console.log('caught');
}

console.log('done');</pre>
            <div class="build">
                <p>
                    The execution stack may not be where you think when the exception is thrown!
                </p>
                <p>
                    node.js convention <code class="prettyprint lang-js">function (err, result) { ... }</code>
                </p>
            </div>
        </article>

        <article>
            <h3>using objects</h3>
            <p>
                Just like in javascript, you can create functions that have instances.
            </p>
            <p>
                Methods are set on the prototype template of a function.
            </p>
            <pre class="prettyprint lang-js">
// 2d point
var Point = function(x, y) {
    this.x = x;
    this.y = y;
};

// return a new point with x,y being the normalized values
// of the current point
Point.prototype.normalized = function() {
    var norm = Math.sqrt(this.x * this.x + this.y * this.y);
    return new Point(this.x/norm, this.y/norm);
};</pre>
            <small>see <em>point</em> directory in project tree</small>
        </article>

        <article class="build">
            <h3>understanding how c++ functions bind to v8</h3>
            <p>
                All methods exposed to v8 are done through static c++ methods.
            </p>
            <p>
                Each javascript object instance has "internal fields" which are used to store
                the raw c++ pointer for backreference.
            </p>
            <p>
                <code class="prettyprint lang-cc">node::ObjectWrap</code> is provided as a convenience to get and set the internal field.
            </p>
            <p>
                Technically, x and y are more encapslated in c++ than in js (setter and getter).
                Use <code class="prettyprint lang-js">Object.defineProperty</code> to achieve the same result in js.
            </p>
            <pre class="prettyprint lang-js">
Object.defineProperty(this, "x", {
    get: function() { return _private_x; },
    set: function(value) { _private_x = value; },
});</pre>
        </article>

        <article>
            <h3>tips</h3>
            <ul class="build">
                <li>
                    argument mangling is better left to js<br/>
                    <small>keep c++ function arguments simple</small>
                </li>
                <li>
                    error checking can be done in js<br/>
                    <small>use caution and be consistent</small>
                </li>
                <li>
                    extend bound prototypes with functions in js<br/>
                    <small>mix and match c++/js definitions</small>
                </li>
                <li>
                    do not recreate built-in functionality</br>
                    <small>file reader, timers, etc...</small>
                </li>
                <li>
                    './src' folder for hpp/cpp files<br/>
                    <small>js files usually in ./lib</small>
                </li>
            </ul>
        </article>

        <article>
            <h3>references</h3>
            <dl>
                <dt>node.js docs</dt>
                <dd><a href="http://nodejs.org/docs/latest/api/">http://nodejs.org/docs/latest/api/</a></dd>
                <dt>v8 api reference</dt>
                <dd><a href="http://izs.me/v8-docs/main.html">http://izs.me/v8-docs/main.html</a></dd>
                <dt>v8 embedders guide</dt>
                <dd><a href="http://code.google.com/apis/v8/embed.html">http://code.google.com/apis/v8/embed.html</a></dd>

                <dt>Mozilla Javascript Docs</dt>
                <dd><a href="https://developer.mozilla.org/en/JavaScript">https://developer.mozilla.org/en/JavaScript</a></dd>
            </dl>
            <h4>misc</h4>
            <dl>
                <dt>node-ffi</dt>
                <dd><a href="https://github.com/rbranson/node-ffi">https://github.com/rbranson/node-ffi</a></dd>

                <dt>another node.js c++ presentation</dt>
                <dd><a href="https://github.com/kkaefer/node-cpp-modules">https://github.com/kkaefer/node-cpp-modules</a></dd>
            </dl>
        </article>
    </section>
</body>
</html>
